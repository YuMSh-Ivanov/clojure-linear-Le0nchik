(ns linear)

(defn v-operation [f & v] (apply mapv f v))
(def v+ (fn [& v] (apply v-operation + v)))
(def v- (fn [& v] (apply v-operation - v)))
(def v* (fn [& v] (apply v-operation * v)))
(def vd (fn [& v] (apply v-operation / v)))
(defn dot [& v] (if (= (count v) 0) 0 (reduce + 0 (apply v* v))))
(defn v*s [v & s] (let [s-multiply (reduce * 1 s)] (mapv #(* % s-multiply) v)))
(defn m-operation [f & m] (apply mapv f m))
(def m+ (fn [& m] (apply m-operation v+ m)))
(def m- (fn [& m] (apply m-operation v- m)))
(def m* (fn [& m] (apply m-operation v* m)))
(def md (fn [& m] (apply m-operation vd m)))
(defn m*s [m & s] (let [s-multiply (reduce * 1 s)] (mapv #(v*s % s-multiply) m)))
(defn transpose [m] (apply mapv vector m))
(defn m*v [m v] (mapv #(dot % v) m))
(defn m*m [& m] (reduce (fn [m1 m2] (let [m2-transposed (transpose m2)] (mapv (fn [i] (mapv (fn [j] (dot i j)) m2-transposed)) m1))) (first m) (rest m)))